# 03 复杂度分析



## 1. 如何分析、统计算法的执行效率和资源消耗？



### 1.1 为什么需要复杂度分析？

所以，我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。

这就是我们今天要讲的时间、空间复杂度分析方法。





## 大o复杂度表示法



### 时间计算

```
 int cal(int n) {
   int sum = 0; // 需要 1 个 unit_time 的执行时间
   int i = 1;   // 需要 1 个 unit_time 的执行时间
   for (; i <= n; ++i) {  // 运行了 n 遍, n 个 unit_time 的执行时间
     sum = sum + i;       // 运行了 n 遍, n 个 unit_time 的执行时间
   }
   return sum;
 }
 // 所以这段代码总的执行时间就是 (2+2n)*unit_time
 // T(n) = O(2n+2)
```



```

 int cal(int n) {
   int sum = 0;  // 1 个 unit_time 的执行时间
   int i = 1;    // 1 个 unit_time 的执行时间
   int j = 1;    // 1 个 unit_time 的执行时间
   for (; i <= n; ++i) {  // n 个 unit_time 的执行时间
     j = 1;               // n 个 unit_time 的执行时间
     for (; j <= n; ++j) { // n^2 个 unit_time 的执行时间
       sum = sum +  i * j; // n^2 个 unit_time 的执行时间
     }
   }
 }
  // 所以这段代码总的执行时间就是 T(n) =  (3+2n+2n^2)*unit_time
  //  T(n) = O(2n2+2n+3)
```




$$
T(n) = O(f(n))
$$


|            |                                                |                                                       |
| ---------- | ---------------------------------------------- | ----------------------------------------------------- |
| T(n)       | 表示代码执行的时间；                           |                                                       |
| n          | 表示数据规模的大小；                           | 以上面代码的举例，在循环中，有n 条记录当然是执行 n 次 |
| f(n)       | 表示每行代码执行的次数总和。                   | 当代码写定时，执行次数纸盒数据量相关，唯一变量        |
| 公式中的 O | 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 |                                                       |

 

可以看出来，所有代码的执行时间 T(n) 与每行代码的执行次数成正比。



假设，每行代码的执行时间是相似的，

所以时间复杂度可以计算所有代码行的执行次数n

表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度（asymptotic time complexity）

T(n)=O(n2)



### 时间复杂度分析

1. 选择代码段中最复杂的，去统计时间复杂度

2. 加法法则：总复杂度等于量级最大的那段代码的复杂度

   

   如果

    T1(n)=O(f(n))，

   T2(n)=O(g(n))；

   那么

   T(n) = T1(n)+T2(n)

   ​        = max( O(f(n)), O(g(n))) 

   ​        = O( max( f(n), g(n) ) )

   

3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积



如果 
$$
T1(n)=O(f(n))，\\

T2(n)=O(g(n))；
$$
那么 
$$
T(n) = T1(n) * T2(n) \\

​       = O( f(n) ) * O( g(n) ) \\

​       =O(f(n) * g(n))
$$


```
int cal(int n) {
   int ret = 0;    
   int i = 1;   
   for (; i < n; ++i) {
     ret = ret + f(i);   
     }  
}   

int f(int n) {
  int sum = 0;
  int i = 1;
  for (; i < n; ++i) {
    sum = sum + i;  
   }   
  return sum; 
}
```

我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) * T2(n) = O(n*n) = O(n2)。





## 几种常见时间复杂度实例分析

![数据结构与算法之美-1](img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-2.png)



### 1. O(1) 复杂度



首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法

一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。





### 2.  O(logn)、O(nlogn)对数阶时间复杂度

同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。



对数

![数据结构与算法之美-1](img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-3.png)

https://www.shuxuele.com/algebra/exponents-logarithms.html

![数据结构与算法之美-1](img/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E-6.png)







## 4. 最好\最坏情况时间复杂度 best case time complexity



最坏情况时间复杂度 worst case time complexity



### 最好情况时间复杂度

就是在最理想的情况下，执行这段代码的时间复杂度。

就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。



### 最坏情况时间复杂度就是

在最糟糕的情况下，执行这段代码的时间复杂度。





## 6. 平均情况时间复杂度average case time complexity





## 7. 均摊时间复杂度amortized time complexity